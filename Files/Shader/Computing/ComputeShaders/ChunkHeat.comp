#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

#define TEMPERATURE_TRANSITION_SPEED 80

#define CHUNK_SIZE 64
#define CHUNK_SIZE_SQUARED 4096

#define DIRECTION_COUNT 4

const ivec2 directions[DIRECTION_COUNT] = {
    ivec2(0, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(0, 1),
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

// flattened arrays (c = chunk, x = x, y = y)
layout(std430, binding = 0) buffer OutputBuffer {
    float voxelTempsOut[];
};
layout(std430, binding = 1) buffer TemperatureBuffer {
    float voxelTemps[];
};
layout(std430, binding = 2) buffer HeatCapacityBuffer {
    float voxelHeatCapacity[];
};
layout(std430, binding = 3) buffer ConductivityBuffer {
    float voxelConductivity[];
};

uniform uint NumberOfVoxels; // total number of voxels in the simulation

layout(std430, binding = 4) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};


void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

    uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

    uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

    float sum = 0.0;

    ivec2 pos = ivec2(x, y);
    ivec2 localPos = ivec2(localX, localY);

    uint NumOfValidDirections = 0;
    for(int i = 0; i < DIRECTION_COUNT; ++i){
        ivec2 testPos = localPos + directions[i];

        ivec2 nPos = pos + directions[i];
        uint nIndex;

        // forbid diagonal heat transfer
        if((testPos.x < 0 || testPos.x >= CHUNK_SIZE) && (testPos.y < 0 || testPos.y >= CHUNK_SIZE))
            continue;

        // if out of bounds from current chunk
        if(testPos.x < 0 || testPos.x >= CHUNK_SIZE || testPos.y < 0 || testPos.y >= CHUNK_SIZE) {
            if(testPos.x < 0){ // right
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkRight == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + CHUNK_SIZE + (nPos.x - CHUNK_SIZE);
            }else if (testPos.x >= CHUNK_SIZE){ // left
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkLeft == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + (CHUNK_SIZE - nPos.x);
            }
            if(testPos.y >= CHUNK_SIZE){ // up
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkUp == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + (CHUNK_SIZE - nPos.y) * CHUNK_SIZE + nPos.x;
            }else if(testPos.y < 0){ // down
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkDown == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + (CHUNK_SIZE + nPos.y) * CHUNK_SIZE + nPos.x;
            }
        }else{ // if in bounds
            nIndex = c * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + nPos.x;
        }

        if (nIndex < 0 || nIndex >= NumberOfVoxels)
            continue;

        ++NumOfValidDirections;
        
        float heatCapacity = voxelHeatCapacity[index]/TEMPERATURE_TRANSITION_SPEED;
        float heatDiff = voxelTemps[nIndex] - voxelTemps[index];
        float heatTrans = heatDiff * voxelConductivity[nIndex] / heatCapacity;

        if(heatCapacity <= 0.0f)
            heatTrans = 0.0f;

        sum += heatTrans;
    }

    if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    voxelTempsOut[index] = voxelTemps[index] + (sum / NumOfValidDirections);
}