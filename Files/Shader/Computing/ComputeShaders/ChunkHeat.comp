#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// flattened arrays (c = chunk, x = x, y = y)
layout(std430, binding = 0) buffer OutputBuffer {
    float voxelTempsOut[];
};
layout(std430, binding = 1) buffer TemperatureBuffer {
    float voxelTemps[];
};
layout(std430, binding = 2) buffer HeatCapacityBuffer {
    float voxelHeatCapacity[];
};
layout(std430, binding = 3) buffer ConductivityBuffer {
    float voxelConductivity[];
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 4) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};
uniform uint NumberOfVoxels; // total number of voxels in the simulation

#define TEMPERATURE_TRANSITION_SPEED 80

#define CHUNK_SIZE 64
#define CHUNK_SIZE_SQUARED 4096

#define DIRECTION_COUNT 4

const ivec2 directions[DIRECTION_COUNT] = {
    ivec2(0, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(0, 1),
};

uint GetVoxelIndex(uint x, uint y, uint chunk) {
    return chunk * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;
}

// output uint(-1) means bad transfer, skip
uint GetIndexFromLocalPosition(ivec2 localPos, uint chunk, uint numberOfChunks) {
    // forbid diagonals
    if((localPos.x < 0 || localPos.x >= CHUNK_SIZE) && (localPos.y < 0 || localPos.y >= CHUNK_SIZE))
        return uint(-1);

    uint index = 0;
    
    // if out of bounds from current chunk
    if(localPos.x < 0 || localPos.x >= CHUNK_SIZE || localPos.y < 0 || localPos.y >= CHUNK_SIZE) {
        int nC = -1;
        if(localPos.x < 0){ // left neighbor chunk
            // Find the left neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkRight == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return uint(-1);
            // x = CHUNK_SIZE-1 in neighbor, y stays the same
            index = GetVoxelIndex(CHUNK_SIZE - 1, localPos.y, nC);

        }else if (localPos.x >= CHUNK_SIZE){ // right neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkLeft == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return uint(-1);
            // x = 0 in neighbor, y stays the same
            index = GetVoxelIndex(0, localPos.y, nC);

        }else if(localPos.y < 0){ // top neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkDown == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return uint(-1);
            // y = CHUNK_SIZE-1 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, CHUNK_SIZE - 1, nC);

        }else if(localPos.y >= CHUNK_SIZE){ // bottom neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkUp == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return uint(-1);
            // y = 0 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, 0, nC);

        }
    }else{ // if in bounds
        index = GetVoxelIndex(localPos.x, localPos.y, chunk);
    }

    return index;
}

void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;   // current chunk

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

    uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

    uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

    float sum = 0.0;

    ivec2 localPos = ivec2(localX, localY);

    uint NumOfValidDirections = 0;
    for(int i = 0; i < DIRECTION_COUNT; ++i){
        ivec2 testPos = localPos + directions[i];

        // get index from position
        uint nIndex = GetIndexFromLocalPosition(testPos, c, numberOfChunks);

        if (nIndex == uint(-1) || nIndex >= NumberOfVoxels)
            continue;

        ++NumOfValidDirections;
        
        float heatCapacity = voxelHeatCapacity[index]/TEMPERATURE_TRANSITION_SPEED;
        float heatDiff = voxelTemps[nIndex] - voxelTemps[index];
        float heatTrans = heatDiff * voxelConductivity[nIndex] / heatCapacity;

        if(heatCapacity <= 0.0f)
            heatTrans = 0.0f;

        sum += heatTrans;
    }

    if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    voxelTempsOut[index] = voxelTemps[index] + (sum / NumOfValidDirections);
}