#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// bigger number = slower
#define PRESSURE_TRANSITION_SPEED 1.1

#define CHUNK_SIZE 64
#define CHUNK_SIZE_SQUARED 4096

#define DIRECTION_COUNT 4

const ivec2 directions[DIRECTION_COUNT] = {
    ivec2(0, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(0, 1),
};
struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 0) buffer OutputChunkBuffer {
    float voxelPressureOut[];
};
layout(std430, binding = 1) buffer IdBuffer {
    uint voxelIds[];
};
layout(std430, binding = 2) buffer PressureBuffer {
    float voxelPressures[];
};

uniform uint NumberOfVoxels; // total number of voxels in the simulation

layout(std430, binding = 3) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};

void main(){
	uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

	uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

	// if not gas, return
	if((voxelIds[index] & (0x1 << 31)) != 0){
		voxelPressureOut[index] = voxelPressures[index];
		return;
	}

	uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

	float sum = 0.0;

	ivec2 pos = ivec2(x, y);
    ivec2 localPos = ivec2(localX, localY);

	uint NumOfValidDirections = 0;
	for(int i = 0; i < DIRECTION_COUNT; ++i){
		ivec2 testPos = localPos + directions[i];
        ivec2 nPos = pos + directions[i];
        uint nIndex;

        // forbid diagonal heat transfer
        if((testPos.x < 0 || testPos.x >= CHUNK_SIZE) && (testPos.y < 0 || testPos.y >= CHUNK_SIZE))
            continue;

		// if out of bounds from current chunk
        if(testPos.x < 0 || testPos.x >= CHUNK_SIZE || testPos.y < 0 || testPos.y >= CHUNK_SIZE) {
            if(testPos.x < 0){ // right
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkRight == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + CHUNK_SIZE + (nPos.x - CHUNK_SIZE);
                ++NumOfValidDirections;
            }else if (testPos.x >= CHUNK_SIZE){ // left
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkLeft == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + (CHUNK_SIZE - nPos.x);
                ++NumOfValidDirections;
            }
            if(testPos.y >= CHUNK_SIZE){ // up
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkUp == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + (CHUNK_SIZE - nPos.y) * CHUNK_SIZE + nPos.x;
                ++NumOfValidDirections;
            }else if(testPos.y < 0){ // down
                int nC = -1;
                for(int i = 0; i < numberOfChunks; ++i){
                    if(chunkData[i].chunkDown == c){
                        nC = chunkData[i].chunk;
                        break;
                    }
                }
                if(nC == -1) continue;
                nIndex = nC * CHUNK_SIZE_SQUARED + (CHUNK_SIZE + nPos.y) * CHUNK_SIZE + nPos.x;
                ++NumOfValidDirections;
            }
        }else{ // if in bounds
            nIndex = c * CHUNK_SIZE_SQUARED + nPos.y * CHUNK_SIZE + nPos.x;
            ++NumOfValidDirections;
        }

		if(voxelIds[index] == voxelIds[nIndex]){
			float pressureDiff = voxelPressures[index] - voxelPressures[nIndex];
			float pressureTransfer = pressureDiff / PRESSURE_TRANSITION_SPEED;
			sum += pressureTransfer;
		}else
			--NumOfValidDirections;
	}

	if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    voxelPressureOut[index] = voxelPressures[index] - (sum / NumOfValidDirections);
}