#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// bigger number = slower
#define PRESSURE_TRANSITION_SPEED 1.1

#define CHUNK_SIZE 64
#define CHUNK_SIZE_SQUARED 4096

#define DIRECTION_COUNT 4

const ivec2 directions[DIRECTION_COUNT] = {
    ivec2(0, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(0, 1),
};
struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 0) buffer OutputChunkBuffer {
    float voxelPressureOut[];
};
layout(std430, binding = 1) buffer IdBuffer {
    uint voxelIds[];
};
layout(std430, binding = 2) buffer PressureBuffer {
    float voxelPressures[];
};

uniform uint NumberOfVoxels; // total number of voxels in the simulation

layout(std430, binding = 3) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};

uint GetVoxelIndex(uint x, uint y, uint chunk) {
    return chunk * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;
}

// output 0 means bad transfer, skip
uint GetIndexFromLocalPosition(ivec2 localPos, uint chunk, uint numberOfChunks) {
    // forbid diagonal heat transfer
    if((localPos.x < 0 || localPos.x >= CHUNK_SIZE) && (localPos.y < 0 || localPos.y >= CHUNK_SIZE))
        return 0;

    uint index = 0;
    
    // if out of bounds from current chunk
    if(localPos.x < 0 || localPos.x >= CHUNK_SIZE || localPos.y < 0 || localPos.y >= CHUNK_SIZE) {
        int nC = -1;
        if(localPos.x < 0){ // left neighbor chunk
            // Find the left neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkRight == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // x = CHUNK_SIZE-1 in neighbor, y stays the same
            index = GetVoxelIndex(CHUNK_SIZE - 1, localPos.y, nC);

        }else if (localPos.x >= CHUNK_SIZE){ // right neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkLeft == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // x = 0 in neighbor, y stays the same
            index = GetVoxelIndex(0, localPos.y, nC);

        }else if(localPos.y < 0){ // top neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkDown == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // y = CHUNK_SIZE-1 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, CHUNK_SIZE - 1, nC);

        }else if(localPos.y >= CHUNK_SIZE){ // bottom neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkUp == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // y = 0 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, 0, nC);

        }
    }else{ // if in bounds
        index = GetVoxelIndex(localPos.x, localPos.y, chunk);
    }

    return index;
}

void main(){
	uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

	uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

	// if not gas, return
	if((voxelIds[index] & (0x1 << 31)) != 0){
		voxelPressureOut[index] = voxelPressures[index];
		return;
	}

	uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

	float sum = 0.0;

    ivec2 localPos = ivec2(localX, localY);

	uint NumOfValidDirections = 0;
	for(int i = 0; i < DIRECTION_COUNT; ++i){
		ivec2 testPos = localPos + directions[i];

        uint nIndex = GetIndexFromLocalPosition(testPos, c, numberOfChunks);

        if (nIndex <= 0 || nIndex >= NumberOfVoxels)
            continue;

        ++NumOfValidDirections;

		if(voxelIds[index] == voxelIds[nIndex]){
			float pressureDiff = voxelPressures[index] - voxelPressures[nIndex];
			float pressureTransfer = pressureDiff / PRESSURE_TRANSITION_SPEED;
			sum += pressureTransfer;
		}else
			--NumOfValidDirections;
	}

	if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    voxelPressureOut[index] = voxelPressures[index] - (sum / NumOfValidDirections);
}