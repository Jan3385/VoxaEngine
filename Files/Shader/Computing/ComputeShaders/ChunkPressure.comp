layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

layout(std430, binding = 0) buffer OutputChunkBuffer {
    float voxelPressureOut[];
};
layout(std430, binding = 1) buffer IdBuffer {
    uint voxelIds[];
};
layout(std430, binding = 2) buffer PressureBuffer {
    float voxelPressures[];
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 3) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};
uniform uint NumberOfVoxels; // total number of voxels in the simulation


// bigger number = slower
#define PRESSURE_TRANSITION_SPEED 1.1

#get CHUNK_SIZE
#get CHUNK_SIZE_SQUARED

#include "IndexFromLocalPos.glsl"

void main(){
	uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

	uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

	// if not gas, return
	if((voxelIds[index] & (0x1 << 31)) != 0){
		voxelPressureOut[index] = voxelPressures[index];
		return;
	}

	uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

	float sum = 0.0;

    ivec2 localPos = ivec2(localX, localY);

	uint NumOfValidDirections = 0;
	for(int i = 0; i < DIRECTION_COUNT; ++i){
		ivec2 testPos = localPos + directions[i];

        uint nIndex = GetIndexFromLocalPositionAtChunk(testPos, c, numberOfChunks);

        if (nIndex == uint(-1) || nIndex >= NumberOfVoxels)
            continue;

        ++NumOfValidDirections;

		if(voxelIds[index] == voxelIds[nIndex]){
			float pressureDiff = voxelPressures[index] - voxelPressures[nIndex];
			float pressureTransfer = pressureDiff / PRESSURE_TRANSITION_SPEED;
			sum += pressureTransfer;
		}else
			--NumOfValidDirections;
	}

	if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    voxelPressureOut[index] = voxelPressures[index] - (sum / NumOfValidDirections);
}