#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

struct ChemicalReactionID {
    uint fromID;
    uint catalystID;
    uint toID;
    float reactionSpeed;
    uint preserveCatalyst;
    float minTemperatureC;
};
struct NewVoxelChange {
    uint newID;
    uint localPosX;
    uint localPosY;
    uint chunk;
};

// flattened arrays (c = chunk, x = x, y = y)
layout(std430, binding = 0) buffer OutputBuffer {
    NewVoxelChange changes[];
};
layout(binding = 1, offset = 0) uniform atomic_uint outputCounter;

uniform uint NumberOfVoxels; // total number of voxels in the simulation
uniform uint randomNumber;

layout(std430, binding = 2) buffer TemperatureBuffer {
    float voxelTemps[];
};

layout(std430, binding = 3) buffer IdBuffer {
    uint voxelIds[];
};

layout(std430, binding = 4) buffer ChemicalReactionsBuffer {
    ChemicalReactionID reactions[];
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 5) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};

#define CHUNK_SIZE 64
#define CHUNK_SIZE_SQUARED 4096

#define DIRECTION_COUNT 4

const ivec2 directions[DIRECTION_COUNT] = {
    ivec2(0, -1),
    ivec2(-1, 0),
    ivec2(1, 0),
    ivec2(0, 1),
};

uint GetVoxelIndex(uint x, uint y, uint chunk) {
    return chunk * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;
}

// output 0 means bad transfer, skip
uint GetIndexFromLocalPosition(ivec2 localPos, uint chunk, uint numberOfChunks) {
    // forbid diagonals
    if((localPos.x < 0 || localPos.x >= CHUNK_SIZE) && (localPos.y < 0 || localPos.y >= CHUNK_SIZE))
        return 0;

    uint index = 0;
    
    // if out of bounds from current chunk
    if(localPos.x < 0 || localPos.x >= CHUNK_SIZE || localPos.y < 0 || localPos.y >= CHUNK_SIZE) {
        int nC = -1;
        if(localPos.x < 0){ // left neighbor chunk
            // Find the left neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkRight == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // x = CHUNK_SIZE-1 in neighbor, y stays the same
            index = GetVoxelIndex(CHUNK_SIZE - 1, localPos.y, nC);

        }else if (localPos.x >= CHUNK_SIZE){ // right neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkLeft == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // x = 0 in neighbor, y stays the same
            index = GetVoxelIndex(0, localPos.y, nC);

        }else if(localPos.y < 0){ // top neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkDown == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // y = CHUNK_SIZE-1 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, CHUNK_SIZE - 1, nC);

        }else if(localPos.y >= CHUNK_SIZE){ // bottom neighbor chunk
            for(int j = 0; j < numberOfChunks; ++j){
                if(chunkData[j].chunkUp == chunk){
                    nC = chunkData[j].chunk;
                    break;
                }
            }
            if(nC == -1) return 0;
            // y = 0 in neighbor, x stays the same
            index = GetVoxelIndex(localPos.x, 0, nC);

        }
    }else{ // if in bounds
        index = GetVoxelIndex(localPos.x, localPos.y, chunk);
    }

    return index;
}

ivec3 GetLocalPosAndChunkFromOOBLocalPos(ivec2 localPos, uint chunk, uint numberOfChunks) {
    // forbid diagonals
    if((localPos.x < 0 || localPos.x >= CHUNK_SIZE) && (localPos.y < 0 || localPos.y >= CHUNK_SIZE))
        return ivec3(0, 0, 0);

    int nC = -1;
    if(localPos.x < 0){ // left neighbor chunk
        for(int j = 0; j < numberOfChunks; ++j){
            if(chunkData[j].chunkRight == chunk){
                nC = chunkData[j].chunk;
                break;
            }
        }
        if(nC == -1) return ivec3(0, 0, 0);
        return ivec3(CHUNK_SIZE - 1, localPos.y, nC);

    }else if (localPos.x >= CHUNK_SIZE){ // right neighbor chunk
        for(int j = 0; j < numberOfChunks; ++j){
            if(chunkData[j].chunkLeft == chunk){
                nC = chunkData[j].chunk;
                break;
            }
        }
        if(nC == -1) return ivec3(0, 0, 0);
        return ivec3(0, localPos.y, nC);

    }else if(localPos.y < 0){ // top neighbor chunk
        for(int j = 0; j < numberOfChunks; ++j){
            if(chunkData[j].chunkDown == chunk){
                nC = chunkData[j].chunk;
                break;
            }
        }
        if(nC == -1) return ivec3(0, 0, 0);
        return ivec3(localPos.x, CHUNK_SIZE - 1, nC);

    }else if(localPos.y >= CHUNK_SIZE){ // bottom neighbor chunk
        for(int j = 0; j < numberOfChunks; ++j){
            if(chunkData[j].chunkUp == chunk){
                nC = chunkData[j].chunk;
                break;
            }
        }
        if(nC == -1) return ivec3(0, 0, 0);
        return ivec3(localPos.x, 0, nC);
    }

    return ivec3(localPos.x, localPos.y, chunk); // in bounds
}

// a random number between 0 and 1
float randomFloat(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return float(seed) / float(0xffffffffu);
}

// gets first index for a reaction array using binary search
int GetReactionIndexStart(uint voxelID) {
    int index = -1;

    int left = 0;
    int right = reactions.length() - 1;

    while(left <= right) {
        int mid = (left + right) / 2;

        if(reactions[mid].fromID == voxelID){
            index = mid;
            break;
        } else if(reactions[mid].fromID < voxelID) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    while(index > 0 && reactions[index-1].fromID == voxelID) {
        index--;
    }

    return index;
}

uint RemoveFlagsFromID(uint id) {
    // Remove the flags from the ID
    return id & 0x3FFFFFFF; // Keep only the lower 30 bits
}

void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;   // current chunk

    uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

    uint voxelID = RemoveFlagsFromID(voxelIds[index]);

    int reactionStart = GetReactionIndexStart(voxelID);
    if(reactionStart == -1) {
        // No reactions for this voxel, nothing to do
        return;
    }

    float temperature = voxelTemps[index];
    uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;
    ivec2 localPos = ivec2(localX, localY);

    for(int i = 0; i < DIRECTION_COUNT; ++i){
        ivec2 testPos = localPos + directions[i];

        // get index from position
        uint nIndex = GetIndexFromLocalPosition(testPos, c, numberOfChunks);

        if (nIndex <= 0 || nIndex >= NumberOfVoxels)
            continue;

        // check reactions
        for(int j = reactionStart; j < reactions.length(); ++j) {
            if(reactions[j].fromID != voxelID)
                break; // no more reactions for this voxel

            if(temperature < reactions[j].minTemperatureC)
                continue; // temperature too low

            if(reactions[j].catalystID != 0 && RemoveFlagsFromID(voxelIds[nIndex]) != reactions[j].catalystID)
                continue; // catalyst not present

            float random = randomFloat(randomNumber * (x + c) + y);
            if(random > reactions[j].reactionSpeed)
                continue; // reaction not triggered

            uint newVoxelIndex = atomicCounterIncrement(outputCounter);
            changes[newVoxelIndex] = NewVoxelChange(reactions[j].toID, localX, localY, c);

            if(!bool(reactions[j].preserveCatalyst)){
                break;
                newVoxelIndex = atomicCounterIncrement(outputCounter);

                ivec3 neighborPos = GetLocalPosAndChunkFromOOBLocalPos(testPos, c, numberOfChunks);

                changes[newVoxelIndex] = NewVoxelChange(reactions[j].catalystID, neighborPos.x, neighborPos.y, neighborPos.z);
            }

            break;
        }
    }
}