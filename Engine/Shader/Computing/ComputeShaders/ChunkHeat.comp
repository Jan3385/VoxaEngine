layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

// flattened arrays (c = chunk, x = x, y = y)
layout(std430, binding = 0) buffer OutputBuffer {
    float voxelTempsOut[];
};
layout(std430, binding = 1) buffer TemperatureBuffer {
    float voxelTemps[];
};
layout(std430, binding = 2) buffer HeatCapacityBuffer {
    float voxelHeatCapacity[];
};
layout(std430, binding = 3) buffer ConductivityBuffer {
    float voxelConductivity[];
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 4) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};
uniform uint NumberOfVoxels; // total number of voxels in the simulation

#define TEMPERATURE_TRANSITION_SPEED 80

const float MAX_HEAT_TRANSFER = 500.0;
const float MIN_TEMP = -273.15;
const float MAX_TEMP = 50000.0;

#get CHUNK_SIZE
#get CHUNK_SIZE_SQUARED

#include "IndexFromLocalPos.glsl"

void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;   // current chunk

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;

    uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

    uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

    float sum = 0.0;

    ivec2 localPos = ivec2(localX, localY);

    uint NumOfValidDirections = 0;
    for(int i = 0; i < DIRECTION_COUNT; ++i){
        ivec2 testPos = localPos + directions[i];

        // get index from position
        uint nIndex = GetIndexFromLocalPositionAtChunk(testPos, c, numberOfChunks);

        if (nIndex == uint(-1) || nIndex >= NumberOfVoxels)
            continue;

        ++NumOfValidDirections;

        //TODO: make more realistic
        
        // clamping to prevent extreme values
        float heatCapacity = clamp(voxelHeatCapacity[index] / TEMPERATURE_TRANSITION_SPEED, 0.01, 10000.0);
        float heatConductivity = clamp(voxelConductivity[nIndex], 0.0, 1000.0);

        float heatDiff = voxelTemps[nIndex] - voxelTemps[index];

        float heatTrans = clamp(heatDiff * heatConductivity / heatCapacity, -MAX_HEAT_TRANSFER, MAX_HEAT_TRANSFER);

        sum += heatTrans;
    }

    if(NumOfValidDirections == 0) NumOfValidDirections = 1;
    
    float newTemp = voxelTemps[index] + (sum / NumOfValidDirections);
    newTemp = clamp(newTemp, MIN_TEMP, MAX_TEMP);

    if(isnan(newTemp) || isinf(newTemp))
        newTemp = voxelTemps[index];

    voxelTempsOut[index] = newTemp;
}