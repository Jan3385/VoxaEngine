layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

struct ChemicalReactionID {
    uint fromID;
    uint catalystID;
    uint toID;
    float reactionSpeed;
    uint preserveCatalyst;
    float minTemperatureC;
};
struct NewVoxelChange {
    uint newID;
    uint localPosX;
    uint localPosY;
    uint chunk;
};

// flattened arrays (c = chunk, x = x, y = y)
layout(std430, binding = 0) buffer OutputBuffer {
    NewVoxelChange changes[];
};
layout(binding = 1, offset = 0) uniform atomic_uint outputCounter;

uniform uint NumberOfVoxels; // total number of voxels in the simulation
uniform uint randomNumber;

layout(std430, binding = 2) buffer TemperatureBuffer {
    float voxelTemps[];
};

layout(std430, binding = 3) buffer IdBuffer {
    uint voxelIds[];
};

layout(std430, binding = 4) buffer ChemicalReactionsBuffer {
    ChemicalReactionID reactions[];
};

struct ChunkConnectivityData{
    int chunk;
    int chunkUp;
    int chunkDown;
    int chunkLeft;
    int chunkRight;
    int _pad[3]; // padding to 32 bytes - 8 * 4 = 32 bytes
};

layout(std430, binding = 5) buffer ChunkBuffer {
    ChunkConnectivityData chunkData[];
};

#get CHUNK_SIZE
#get CHUNK_SIZE_SQUARED

#include "IndexFromLocalPos.glsl"

// a random number between 0 and 1
float randomFloat(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return float(seed) / float(0xffffffffu);
}

// gets first index for a reaction array using binary search
int GetReactionIndexStart(uint voxelID) {
    int index = -1;

    int left = 0;
    int right = reactions.length() - 1;

    while(left <= right) {
        int mid = (left + right) / 2;

        if(reactions[mid].fromID == voxelID){
            index = mid;
            break;
        } else if(reactions[mid].fromID < voxelID) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    while(index > 0 && reactions[index-1].fromID == voxelID) {
        index--;
    }

    return index;
}

uint RemoveFlagsFromID(uint id) {
    // Remove the flags from the ID
    return id & 0x3FFFFFFF; // Keep only the lower 30 bits
}

void main(){
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint c = gl_GlobalInvocationID.z;   // current chunk

    uint index = c * CHUNK_SIZE_SQUARED + y * CHUNK_SIZE + x;

    uint voxelID = RemoveFlagsFromID(voxelIds[index]);

    int reactionStart = GetReactionIndexStart(voxelID);
    if(reactionStart == -1) {
        // No reactions for this voxel, nothing to do
        return;
    }

    float temperature = voxelTemps[index];
    uint numberOfChunks = NumberOfVoxels / CHUNK_SIZE_SQUARED;

    uint localX = x % CHUNK_SIZE;
    uint localY = y % CHUNK_SIZE;
    ivec2 localPos = ivec2(localX, localY);

    for(int i = 0; i < DIRECTION_COUNT; ++i){
        ivec2 testPos = localPos + directions[i];

        // get index from position
        uint nIndex = GetIndexFromLocalPositionAtChunk(testPos, c, numberOfChunks);

        if (nIndex == uint(-1) || nIndex >= NumberOfVoxels)
            continue;

        // check reactions
        for(int j = reactionStart; j < reactions.length(); ++j) {
            if(reactions[j].fromID != voxelID)
                break; // no more reactions for this voxel

            if(temperature < reactions[j].minTemperatureC)
                continue; // temperature too low

            if(reactions[j].catalystID != 0 && RemoveFlagsFromID(voxelIds[nIndex]) != reactions[j].catalystID)
                continue; // catalyst not present

            float random = randomFloat(randomNumber * (x + c) + y);
            if(random > reactions[j].reactionSpeed)
                continue; // reaction not triggered

            uint newVoxelIndex = atomicCounterIncrement(outputCounter);
            changes[newVoxelIndex] = NewVoxelChange(reactions[j].toID, localX, localY, c);

            if((reactions[j].preserveCatalyst & 1) == 0){
                ivec3 neighborPos = GetLocalPosAndChunkFromOOBLocalPos(testPos, c, numberOfChunks);

                if(neighborPos != ivec3(-1, -1, -1)){
                    newVoxelIndex = atomicCounterIncrement(outputCounter);
                    changes[newVoxelIndex] = NewVoxelChange(reactions[j].toID, neighborPos.x, neighborPos.y, neighborPos.z);
                }
            }

            break;
        }
    }
}